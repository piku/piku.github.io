{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"<p><code>piku</code>, inspired by <code>dokku</code>, allows you do <code>git push</code> deployments to your own servers, no matter how small they are.</p> <p>  Installing       Using/Features       Managing and Monitoring       Examples       Web App Tutorial      </p>"},{"location":"index.html#demo","title":"Demo","text":""},{"location":"index.html#workflow","title":"Workflow","text":"<p><code>piku</code> supports a Heroku-like workflow:</p> <ul> <li>Create a <code>git</code> SSH remote pointing to your <code>piku</code> server with the app name as repo name:   <code>git remote add piku piku@yourserver:appname</code>.</li> <li>Push your code: <code>git push piku master</code> (or if you want to push a different branch than the current one use <code>git push piku release-branch-name</code>).</li> <li><code>piku</code> determines the runtime and installs the dependencies for your app (building whatever's required).</li> <li>It then looks at a <code>Procfile</code> and starts matching worker processes.</li> <li>You can optionally also specify a <code>release</code> worker which is run once when the app is deployed.</li> <li>You can then remotely change application settings (<code>config:set</code>) or scale up/down worker processes (<code>ps:scale</code>).</li> <li>You can also bake application and <code>nginx</code> settings into an <code>ENV</code> configuration file. </li> </ul> <p>You can also deploy a <code>gh-pages</code> style static site using a <code>static</code> worker type, with the root path as the argument, and run a <code>release</code> task to do some processing on the server after <code>git push</code>.</p>"},{"location":"index.html#project-activity","title":"Project Activity","text":"<p><code>piku</code> is considered STABLE. It is actively maintained, but \"actively\" here means the feature set is pretty much done, so it is only updated when new language runtimes are added or reproducible bugs crop up.</p> <p>It currently requires Python 3.8 or above, which is the baseline in Ubuntu LTS 20.04 while Debian 11 has already moved on to 3.9. Sometime in 2025 this will be changed according to the next section.</p>"},{"location":"index.html#deprecation-notices","title":"Deprecation Notices","text":"<p>Since most of its users run it on LTS distributions, there is no rush to introduce disruption. The current plan is to throw up a warning for older runtimes and do regression testing for 3.10-3.12 (replacing the current bracket of tests from 3.8 to 3.12), and make sure we also cover Ubuntu 22.04, Debian 11 and Fedora 39+.</p>"},{"location":"FAQ.html","title":"FAQ","text":"<p>Q: Why <code>piku</code>?</p> <p>A: Partly because it's started out on the Raspberry Pi, because it's Japanese onomatopeia for 'twitch' or 'jolt', and because we knew the name would be cute and amusing.</p> <p>Q: Why Python/why not Go?</p> <p>A: We actually thought about doing this in Go right off the bat, but click is so cool and we needed to have <code>uwsgi</code> running anyway, so we caved in. But possible future directions are likely to take something like suture and port this across (or just use Caddy), doing away with <code>uwsgi</code> altogether.</p> <p>Go also (at the time) did not have a way to vendor dependencies that we were comfortable with, and that is also why Go support fell behind. Hopefully that will change soon.</p> <p>Q: Does it run under Python 3?</p> <p>A: Right now, it only runs on Python 3, even though it can deploy apps written in both major versions. It began its development using 2.7 and using<code>click</code> for abstracting the simpler stuff, and we eventually switched over to 3.5 once it was supported in Debian Stretch and Raspbian since we wanted to make installing it on the Raspberry Pi as simple as possible.</p> <p>Q: Why not just use <code>dokku</code>?</p> <p>A: We used <code>dokku</code> daily for many projects. But it relied on a number of <code>x64</code> containers that needed to be completely rebuilt for <code>ARM</code>, and when we decided we needed something like this (March 2016) that was barely possible - <code>docker</code> itself was not fully baked for <code>ARM</code> yet, and people were at the time just starting to get <code>herokuish</code> and <code>buildstep</code> to build on <code>ARM</code>.</p>"},{"location":"features.html","title":"Features","text":""},{"location":"features.html#workflow","title":"Workflow","text":"<p><code>piku</code> supports a Heroku-like workflow:</p> <ul> <li>Create a <code>git</code> SSH remote pointing to your <code>piku</code> server with the app name as repo name:   <code>git remote add piku piku@yourserver:appname</code>.</li> <li>Push your code: <code>git push piku master</code> (or if you want to push a different branch than the current one use <code>git push piku release-branch-name</code>).</li> <li><code>piku</code> determines the runtime and installs the dependencies for your app (building whatever's required).</li> <li>For Python, it segregates each app's dependencies into a <code>virtualenv</code>.</li> <li>For Go, it defines a separate <code>GOPATH</code> for each app.</li> <li>For Node, it installs whatever is in <code>package.json</code> into <code>node_modules</code>.</li> <li>For Java, it builds your app depending on either <code>pom.xml</code> or <code>build.gradle</code> file.</li> <li>For Clojure, it can use either <code>leiningen</code> or the Clojure CLI and a <code>deps.edn</code> file.</li> <li>For Ruby, it does <code>bundle install</code> of your gems in an isolated folder.</li> <li>It then looks at a <code>Procfile</code> and starts the relevant workers using <code>uwsgi</code> as a generic process manager.</li> <li>You can optionally also specify a <code>release</code> worker which is run once when the app is deployed.</li> <li>You can then remotely change application settings (<code>config:set</code>) or scale up/down worker processes (<code>ps:scale</code>).</li> <li>You can also bake application and <code>nginx</code> settings into an <code>ENV</code> configuration file.</li> </ul> <p>You can also deploy a <code>gh-pages</code> style static site using a <code>static</code> worker type, with the root path as the argument, and run a <code>release</code> task to do some processing on the server after <code>git push</code>.</p>"},{"location":"features.html#virtual-hosts-and-ssl","title":"Virtual Hosts and SSL","text":"<p><code>piku</code> has full virtual host support - i.e., you can host multiple apps on the same VPS and use DNS aliases to access them via different hostnames. </p> <p><code>piku</code>  will also set up either a private certificate or obtain one via Let's Encrypt to enable SSL.</p> <p>If you are on a LAN and are accessing <code>piku</code> from macOS/iOS/Linux clients, you can try using <code>piku/avahi-aliases</code> to announce different hosts for the same IP address via Avahi/mDNS/Bonjour.</p>"},{"location":"features.html#caching-and-static-paths","title":"Caching and Static Paths","text":"<p>Besides static sites, <code>piku</code> also supports directly mapping specific URL prefixes to filesystem paths (to serve static assets) or caching back-end responses (to remove load from applications).</p> <p>These features are configured by setting appropriate values in the <code>ENV</code> file.</p>"},{"location":"features.html#supported-platforms","title":"Supported Platforms","text":"<p><code>piku</code> is intended to work in any POSIX-like environment where you have Python, <code>nginx</code>, <code>uwsgi</code> and <code>ssh</code>: it has been deployed on Linux, FreeBSD, [Cygwin][cygwin] and the [Windows Subsystem for Linux][wsl].</p> <p>As a baseline, it began its development on an original 256MB Rasbperry Pi Model B, and still runs reliably on it.</p> <p>But its main use is as a micro-PaaS to run applications on cloud servers with both Intel and ARM CPUs, with either Debian or Ubuntu Linux as target platforms.</p>"},{"location":"features.html#supported-runtimes","title":"Supported Runtimes","text":"<p><code>piku</code> currently supports apps written in Python, Node, Clojure, Java and a few other languages (like Go) in the works.</p> <p>But as a general rule, if it can be invoked from a shell, it can be run inside <code>piku</code>.</p>"},{"location":"manage.html","title":"Manage","text":""},{"location":"manage.html#managing-your-piku-apps","title":"Managing your Piku apps","text":"<p>To make life easier you can also install the <code>piku</code> helper into your path (e.g. <code>~/bin</code>):</p> <pre><code>curl https://raw.githubusercontent.com/piku/piku/master/piku &gt; ~/bin/piku &amp;&amp; chmod 755 ~/bin/piku\n</code></pre> <p>This shell script simplifies working with multiple <code>piku</code> remotes and applications:</p> <ul> <li>If you <code>cd</code> into a project folder that has a <code>git</code> remote called <code>piku</code> the helper will infer the remote server and app name and use them automatically:</li> </ul> <pre><code>$ piku logs\n$ piku config:set MYVAR=12\n$ piku stop\n$ piku deploy\n$ piku destroy\n$ piku # &lt;- show available remote and local commands\n</code></pre> <ul> <li>If you are starting a new project, <code>piku init</code> will download example <code>Procfile</code> and <code>ENV</code> files into the current folder:</li> </ul> <pre><code>$ piku init\nWrote ./ENV file.\nWrote ./Procfile.\n</code></pre> <ul> <li>The <code>piku</code> helper also lets you pass settings to the underlying SSH command: <code>-t</code> to run interactive commands remotely, and <code>-A</code> to proxy authentication credentials in order to do remote <code>git</code> pulls.</li> </ul> <p>For instance, here's how to use the <code>-t</code> flag to obtain a <code>bash</code> shell in the app directory of one of your <code>piku</code> apps:</p> <pre><code>$ piku -t run bash\nPiku remote operator.\nServer: piku@cloud.mccormickit.com\nApp: dashboard\n\npiku@piku:~/.piku/apps/dashboard$ ls\ndata  ENV  index.html  package.json  package-lock.json  Procfile  server.wisp\n</code></pre>"},{"location":"manage.html#monitoring","title":"Monitoring","text":"<p>Besides using the <code>logs</code> command, there is a sample monitoring application to keep tabs on resource usage.</p>"},{"location":"community/index.html","title":"Community","text":"<p>There is an active discussion forum for <code>piku</code> where you can ask questions, share your deployments, and discuss new features, and we have a published roadmap.</p>"},{"location":"community/index.html#southern-california-linux-expo-talk-by-john-matthew-2024","title":"Southern California Linux Expo Talk by John Matthew (2024)","text":""},{"location":"community/index.html#gource-visualization-2021","title":"Gource Visualization (2021)","text":""},{"location":"community/index.html#linuxconf-talk-by-chris-mccormick-2020","title":"LinuxConf Talk by Chris McCormick (2020)","text":""},{"location":"community/index.html#references","title":"References","text":"<ul> <li>Fast Web App Tutorial</li> </ul> <p>  Contributing       Examples      </p>"},{"location":"community/contributing.html","title":"Contributing","text":"<p><code>piku</code> is a stable project, but we welcome contributions that:</p> <ul> <li>Help us move beyond Python 3.8+ (which is the current target due to Linux LTS distribution alignment)</li> <li>Help us do better automated testing</li> <li>Improve documentation (some docs are a bit old by now)</li> <li>Help us deploy <code>piku</code> in various Linux distributions and environments (check the sister repositories in the project)</li> <li>Provide sample deployments of common applications (again, check the sister repositories in the project)</li> <li>Allow us to better support more language runtimes</li> <li>Allow us to support different web servers or process supervisors (Caddy springs to mind as a popular alternative for small VPSes)</li> </ul>"},{"location":"community/contributing.html#code-size-style","title":"Code Size / Style","text":"<p>By its very nature, <code>piku</code> is a very small program. By today's standards of all-encompassing solutions this may seem strange, but it would benefit from being kept that way.</p> <ul> <li>Small and focused PRs. Please don't include changes that don't address the subject of your PR.</li> <li>Follow the style of importing functions directly e.g. <code>from os.path import abspath</code></li> <li>Follow <code>PEP8</code>.</li> </ul> <p>So please keep that in mind when contributing.</p> <p>For instance, if your runtime or framework needs additional setup, it might be better to contribute an utility script to run in a <code>release</code> entry in the <code>Procfile</code> rather than patching <code>piku.py</code>--but do hack at it if that is the best way to achieve it.</p>"},{"location":"community/examples.html","title":"Example Applications","text":"<p>Besides the bundled examples, there are a number of community-contributed examples that can be deployed using <code>piku</code>.</p> <p>They are meant to be illustrative of the kinds of applications that can be deployed using <code>piku</code>, and are not meant to be exhaustive.</p>"},{"location":"community/examples.html#pre-built-apps-and-tools","title":"Pre-built Apps and Tools","text":"<ul> <li>avahi-aliases, a tool for announcing multiple hostnames on the same IP address via Avahi/mDNS/Bonjour.</li> <li>Node-RED</li> <li>Gitea</li> <li>WebDAV, a simple WebDAV server</li> <li>SnapDrop, a simple LAN file sharing application using Express.</li> </ul>"},{"location":"community/examples.html#phoenix","title":"Phoenix","text":"<ul> <li>Sample Phoenix App</li> </ul>"},{"location":"community/examples.html#python","title":"Python","text":"<ul> <li>Sample Python App</li> <li>Sample Django App</li> </ul>"},{"location":"community/examples.html#ruby-on-rails","title":"Ruby on Rails","text":"<ul> <li>Sample Ruby on Rails App</li> </ul>"},{"location":"community/examples.html#nodejs","title":"NodeJS","text":"<ul> <li>Sample NodeJS App</li> <li>Piku Monitor - a simple monitoring tool for <code>piku</code> apps, written in ClojureScript</li> </ul>"},{"location":"community/examples.html#java","title":"Java","text":"<ul> <li>Sample Java App</li> </ul>"},{"location":"community/examples.html#clojure","title":"Clojure","text":"<ul> <li>Sample Clojure App</li> </ul>"},{"location":"community/examples.html#bare-metal-c","title":"Bare Metal C","text":"<ul> <li>Sample C App</li> </ul>"},{"location":"configuration/index.html","title":"Configuring Applications","text":"<p>A minimal <code>piku</code> app has a root directory structure similar to  this:</p> <pre><code>ENV\nProcfile\napp.py\nworker.py\nrequirements.txt\n</code></pre> <p>  ENV       Procfile      </p>"},{"location":"configuration/index.html#configuration-files","title":"Configuration Files","text":"<p><code>piku</code> relies on two configuration files shipped with your app to determine how to run it: <code>ENV</code> and <code>Procfile</code>.</p> <ul> <li>The <code>ENV</code> file contains environment variables that allow you to configure both <code>piku</code> and your app, following the 12-factor app approach.</li> <li>The <code>Procfile</code> tells <code>piku</code> what kind of workers to run</li> </ul>"},{"location":"configuration/index.html#runtime-detection","title":"Runtime Detection","text":"<p>Besides <code>ENV</code> and <code>Procfile</code>, <code>piku</code> also looks for runtime-specific files in the root of your app's directory:</p> <ul> <li>If there's a <code>requirements.txt</code> or <code>pyproject.toml</code> file at the top level, then the app is assumed to require Python. Installing an app with a <code>pyproject.toml</code> will require poetry or uv.</li> <li>If there's a <code>Gemfile</code> at the top level, then the app is assumed to require Ruby.</li> <li>If there's a <code>package.json</code> file at the top level, then the app is assumed to require Node.js.</li> <li>If there's a <code>pom.xml</code> or a <code>build.gradle</code> file at the top level, then the app is assumed to require Java.</li> <li>If there's a <code>deps.edn</code> or <code>project.clj</code> file at the top level, then the app is assumed to require Clojure.</li> <li>If there's a <code>Godeps</code> file at the top level, then the app is assumed to require Go.</li> </ul> <p>Info</p> <p><code>go.mod</code> support is currently in development.</p> <p>These are not exclusive, however. There is also a sample Phoenix app that demonstrates how to add support for additional runtimes.</p>"},{"location":"configuration/env.html","title":"<code>ENV</code> Variables","text":"<p>You can configure deployment settings by placing special variables in an <code>ENV</code> file deployed with your app. This file should be placed in the root of your app's directory, and can look something like this:</p> <pre><code># variables are global and can be replaced\nSETTING1=True\nSETTING2=${SETTING1}/Maybe\n\n# addr:port\nPORT=9080\nBIND_ADDRESS=0.0.0.0\n\n# the max number the worker will process\nRANGE=10\n\n# worker sleep interval between prints\nINTERVAL=1\n</code></pre>"},{"location":"configuration/env.html#runtime-settings","title":"Runtime Settings","text":"<ul> <li><code>PIKU_AUTO_RESTART</code> (boolean, defaults to <code>true</code>): Piku will restart all workers every time the app is deployed. You can set it to <code>0</code>/<code>false</code> if you prefer to deploy first and then restart your workers separately.</li> </ul>"},{"location":"configuration/env.html#python","title":"Python","text":"<ul> <li><code>PYTHON_VERSION</code> (int): Forces Python 3</li> </ul> <p>Warning</p> <p>This is mostly deprecated (since <code>piku</code> now runs solely on Python 3.x), but is kept around for legacy compatibility.</p>"},{"location":"configuration/env.html#node","title":"Node","text":"<ul> <li><code>NODE_VERSION</code>: installs a particular version of node for your app if <code>nodeenv</code> is found on the path. Optional; if not specified, the system-wide node package is used.</li> <li><code>NODE_PACKAGE_MANAGER</code>: use an alternate package manager (e.g. set to <code>yarn</code> or <code>pnpm</code>). The package manager will be installed with <code>npm install -g</code>.</li> </ul> <p>Note</p> <p>you will need to stop and re-deploy the app to change the <code>node</code> version in a running app.</p>"},{"location":"configuration/env.html#network-settings","title":"Network Settings","text":"<ul> <li><code>BIND_ADDRESS</code>: IP address to which your app will bind (typically <code>127.0.0.1</code>)</li> <li><code>PORT</code>: TCP port for your app to listen in (if deploying your own web listener).</li> <li><code>DISABLE_IPV6</code> (boolean): if set to <code>true</code>, it will remove IPv6-specific items from the <code>nginx</code> config, which will accept only IPv4 connections</li> </ul>"},{"location":"configuration/env.html#uwsgi-settings","title":"uWSGI Settings","text":"<ul> <li><code>UWSGI_MAX_REQUESTS</code> (integer): set the <code>max-requests</code> option to determine how many requests a worker will receive before it's recycled.</li> <li><code>UWSGI_LISTEN</code> (integer): set the <code>listen</code> queue size.</li> <li><code>UWSGI_PROCESSES</code> (integer): set the <code>processes</code> count.</li> <li><code>UWSGI_ENABLE_THREADS</code> (boolean): set the <code>enable-threads</code> option.</li> <li><code>UWSGI_LOG_MAXSIZE</code> (integer): set the <code>log-maxsize</code>.</li> <li><code>UWSGI_LOG_X_FORWARDED_FOR</code> (boolean): set the <code>log-x-forwarded-for</code> option.</li> <li><code>UWSGI_GEVENT</code>: enable the Python 2 <code>gevent</code> plugin</li> <li><code>UWSGI_ASYNCIO</code> (integer): enable the Python 2/3 <code>asyncio</code> plugin and set the number of tasks</li> <li><code>UWSGI_INCLUDE_FILE</code>: a uwsgi config file in the app's dir to include - useful for including custom uwsgi directives.</li> <li><code>UWSGI_IDLE</code> (integer): set the <code>cheap</code>, <code>idle</code> and <code>die-on-idle</code> options to have workers spawned on demand and killed after n seconds of inactivity. </li> </ul> <p>Note</p> <p><code>UWSGI_IDLE</code> applies to all the workers, so if you have <code>UWSGI_PROCESSES</code> set to 4, they will all be killed simultaneously. Support for progressive scaling of workers via <code>cheaper</code> and similar uWSGI configurations will be added in the future. </p>"},{"location":"configuration/env.html#nginx-settings","title":"<code>nginx</code> Settings","text":"<ul> <li><code>NGINX_SERVER_NAME</code>: set the virtual host name associated with your app</li> <li><code>NGINX_STATIC_PATHS</code> (string, comma separated list): set an array of <code>/url:path</code> values that will be served directly by <code>nginx</code></li> <li><code>NGINX_CLOUDFLARE_ACL</code> (boolean, defaults to <code>false</code>): activate an ACL allowing access only from Cloudflare IPs</li> <li><code>NGINX_HTTPS_ONLY</code> (boolean, defaults to <code>false</code>): tell <code>nginx</code> to auto-redirect non-SSL traffic to SSL site. </li> </ul> <p>Note</p> <p>if used with Cloudflare, <code>NGINX_HTTPS_ONLY</code> will cause an infinite redirect loop - keep it set to <code>false</code>, use <code>NGINX_CLOUDFLARE_ACL</code> instead and add a Cloudflare Page Rule to \"Always Use HTTPS\" for your server (use <code>domain.name/*</code> to match all URLs). </p>"},{"location":"configuration/env.html#nginx-caching","title":"<code>nginx</code> Caching","text":"<p>When <code>NGINX_CACHE_PREFIXES</code> is set, <code>nginx</code> will cache requests for those URL prefixes to the running application (<code>uwsgi</code>-like or <code>web</code> workers) and reply on its own for <code>NGINX_CACHE_TIME</code> to the outside. This is meant to be used for compute-intensive operations like resizing images or providing large chunks of data that change infrequently (like a sitemap). </p> <p>The behavior of the cache can be controlled with the following variables:</p> <ul> <li><code>NGINX_CACHE_PREFIXES</code> (string, comma separated list): set an array of <code>/url</code> values that will be cached by <code>nginx</code></li> <li><code>NGINX_CACHE_SIZE</code> (integer, defaults to 1): set the maximum size of the <code>nginx</code> cache, in GB</li> <li><code>NGINX_CACHE_TIME</code> (integer, defaults to 3600): set the amount of time (in seconds) that valid backend replies (<code>200 304</code>) will be cached.</li> <li><code>NGINX_CACHE_REDIRECTS</code> (integer, defaults to 3600): set the amount of time (in seconds) that backend redirects (<code>301 307</code>) will be cached.</li> <li><code>NGINX_CACHE_ANY</code> (integer, defaults to 3600): set the amount of time (in seconds) that any other replies (other than errors) will be cached.</li> <li><code>NGINX_CACHE_CONTROL</code> (integer, defaults to 3600): set the amount of time (in seconds) for cache control headers (<code>Cache-Control \"public, max-age=3600\"</code>)</li> <li><code>NGINX_CACHE_EXPIRY</code> (integer, defaults to 86400): set the amount of time (in seconds) that cache entries will be kept on disk.</li> <li><code>NGINX_CACHE_PATH</code> (string, detaults to <code>~piku/.piku/&lt;appname&gt;/cache</code>): location for the <code>nginx</code> cache data.</li> </ul> <p>Note</p> <p><code>NGINX_CACHE_PATH</code> will be completely managed by <code>nginx</code> and cannot be removed by Piku when the application is destroyed. This is because <code>nginx</code> sets the ownership for the cache to be exclusive to itself, and the <code>piku</code> user cannot remove that file tree. So you will either need to clean it up manually after destroying the app or store it in a temporary filesystem (or set the <code>piku</code> user to the same UID as <code>www-data</code>, which is not recommended).</p> <p>Right now, there is no provision for cache revalidation (i.e., <code>nginx</code> asking your backend if the cache entries are still valid), since that requires active application logic that varies depending on the runtime--<code>nginx</code> will only ask your backend for new content when <code>NGINX_CACHE_TIME</code> elapses. If you require that kind of behavior, that is still possible via <code>NGINX_INCLUDE_FILE</code>.</p> <p>Also, keep in mind that using <code>nginx</code> caching with a <code>static</code> website worker will not work (and there's no point to it either).</p>"},{"location":"configuration/env.html#nginx-overrides","title":"<code>nginx</code> Overrides","text":"<ul> <li><code>NGINX_INCLUDE_FILE</code>: a file in the app's dir to include in nginx config <code>server</code> section - useful for including custom <code>nginx</code> directives.</li> <li><code>NGINX_ALLOW_GIT_FOLDERS</code>: (boolean) allow access to <code>.git</code> folders (default: false, blocked)</li> </ul>"},{"location":"configuration/env.html#acme-settings","title":"Acme Settings","text":"<ul> <li><code>ACME_ROOT_CA</code>: set the certificate authority that Acme should use to generate public ssl certificates (string, default: <code>letsencrypt.org</code>)</li> </ul>"},{"location":"configuration/procfile.html","title":"<code>Procfile</code> format","text":"<p><code>piku</code> supports a Heroku-like <code>Procfile</code> that you provide to indicate how to run one or more application processes (what Heroku calls \"dynos\"):</p> <pre><code>web: embedded_server --port $PORT\nworker: background_worker\n</code></pre>"},{"location":"configuration/procfile.html#worker-types","title":"Worker Types","text":"<p><code>piku</code> supports seven different kinds of worker processes:</p> <p><pre><code># A module to be loaded by uwsgi to serve HTTP requests\nwsgi: module.submodule:app\n# A background worker, using the default name\nworker: python long_running_script.py\n# Another worker with a different name\nfetcher: python fetcher.py\n# Simple cron expression: minute [0-59], hour [0-23], day [0-31], month [1-12], weekday [1-7] (starting Monday, no ranges allowed on any field)\ncron: 0 0 * * * python midnight_cleanup.py\nrelease: python initial_cleanup.py\n</code></pre> Each of these has slightly different features:</p>"},{"location":"configuration/procfile.html#wsgi","title":"<code>wsgi</code>","text":"<p><code>wsgi</code> workers are Python-specific and must be specified in the format <code>dotted.module:entry_point</code>. <code>uwsgi</code> will load the specified module and call the <code>entry_point</code> function to start the application, handling all the HTTP requests directly (your Python code will run the handlers, but will run as a part of the <code>uwsgi</code> process).</p> <p><code>uwsgi</code> will automatically spawn multiple workers for you, and you can control the number of workers via the <code>UWSGI_PROCESSES</code> environment variable.</p> <p>Also, in this mode <code>uwsgi</code> will talk to <code>nginx</code> via a Unix socket, so you don't need to worry about the HTTP server at all.</p>"},{"location":"configuration/procfile.html#php","title":"<code>php</code>","text":"<p><code>php</code> workers will execute PHP code in files with the <code>.php</code> extension and serve other files. For security reasons, files with the '.inc' extension are not executed.</p> <p>Note</p> <p>You will need to install the uwsgi-plugin-php package for Debian-based systems, such as Ubuntu, or the equivalent for your distro. This package is available for Ubuntu 20.04 and 24.04, but seems to have been withdrawn from 22.04.</p> <p>Note</p> <p>If you place a <code>php.ini</code> file in the root of your app, the PHP interpreter for this app will ignore the default system <code>php.ini</code>. If your distro is configured to include additional files from an auxiliary directory, those files will continue to be processed.</p>"},{"location":"configuration/procfile.html#web","title":"<code>web</code>","text":"<p><code>web</code> workers can be literally any executable that <code>uwsgi</code> can run and that will serve HTTP requests. They must (by convention) honor the <code>PORT</code> environment variable, so that the <code>nginx</code> reverse proxy can talk to them.</p>"},{"location":"configuration/procfile.html#worker","title":"<code>worker</code>","text":"<p><code>worker</code> processes are just standard processes that run in the background. They can actually have arbitrary names, and the idea is that they would perform any tasks your app requires that isn't directly related to serving web pages.</p>"},{"location":"configuration/procfile.html#static","title":"<code>static</code>","text":"<p><code>static</code> workers are simply a way to direct <code>nginx</code> to mount the first argument as a static path and serve it directly. This is useful for serving (and caching) static files directly from your app, without having to go through application code.</p> <p>Note</p> <p>See <code>nginx</code> caching for more information on how to configure <code>nginx</code> to serve static files.</p>"},{"location":"configuration/procfile.html#cron","title":"<code>cron</code>","text":"<p>A <code>cron</code> worker is a process that runs at a specific time (or intervals), using a simplified <code>crontab</code> expression preceding the command to be run (e.g. <code>cron: */5 * * * * python batch.py</code> to run a batch every 5 minutes)</p> <p>Multiple crons can be scheduled by simply adding multiple entries with <code>cron</code> prefix.</p> <pre><code>...\ncron1: */5 * * * * python batch.py\ncron2: 0 * * * * python batch.py\n...\n</code></pre> <p>Warning</p> <p><code>crontab</code> expressions are simplified and do not support ranges or lists, only single values, splits and <code>*</code> (wildcard).</p>"},{"location":"configuration/procfile.html#alternatives","title":"alternatives","text":"<p><code>Python</code> apscheduler - Provides it's own library for scheduling jobs, and honors the full regex of crontab.</p>"},{"location":"configuration/procfile.html#preflight","title":"<code>preflight</code>","text":"<p><code>preflight</code>  is a special \"worker\" that is run once before the app is deployed and dependencies are installed (can be useful for cleanups, like resetting caches, removing older versions of files, etc).</p>"},{"location":"configuration/procfile.html#release","title":"<code>release</code>","text":"<p><code>release</code> which is a special worker that is run once when the app is deployed, after installing dependencies (can be useful for build steps).</p> <p>Any worker will be automatically respawned upon failure ([uWSGI][uwsgi] will automatically shun/throttle crashy workers).</p>"},{"location":"design/index.html","title":"Design","text":"<p>The idea behind <code>piku</code> is that it provides the simplest possible way to deploy web apps or services. Simplicity comes at the expense of features, of course, and this document tries to capture the trade-offs.</p>"},{"location":"design/index.html#core-values","title":"Core values","text":"<ul> <li>Run on low end devices.</li> <li>Accessible to hobbyists and K-12 schools.</li> <li>~1500 lines readable code.</li> <li>Functional code style.</li> <li>Few (single?) dependencies</li> <li>12 factor app.</li> <li>Simplify user experience.</li> <li>Cover 80% of common use cases.</li> <li>Sensible defaults for all features.</li> <li>Leverage distro packages in Raspbian/Debian/Ubuntu (Alpine and RHEL support is WIP)</li> <li>Leverage standard tooling (<code>git</code>, <code>ssh</code>, <code>uwsgi</code>, <code>nginx</code>).</li> <li>Preserve backwards compatibility where possible</li> </ul>"},{"location":"design/index.html#why-uwsgi","title":"Why uWSGI","text":"<p>Using uWSGI in emperor mode gives us the following features for free:</p> <ul> <li>Painless Python WSGI and <code>virtualenv</code> integration</li> <li>Process monitoring, restarting, basic resource limiting, etc.</li> <li>Basic security scaffolding, beginning with the ability to define <code>uid</code>/<code>gid</code> on a per-app basis (if necessary)</li> </ul>"},{"location":"design/index.html#application-packaging","title":"Application packaging","text":"<p>An app is simply a <code>git</code> repository with some additional files on the top level, the most important of which is the <code>Procfile</code>.</p>"},{"location":"design/index.html#env-settings","title":"<code>ENV</code> settings","text":"<p>Since <code>piku</code> is targeted at 12 Factor apps, it allows you to set environment variables in a number of ways, the simplest of which is by adding an <code>ENV</code> file to your repository:</p> <pre><code>SETTING1=foo\n# piku supports comments and variable expansion\nSETTING2=${SETTING1}/bar\n# if this isn't defined, piku will assign a random TCP port\nPORT=9080\n</code></pre> <p>See configuration for a full list of environment variables that can also be set.</p> <p>Environment variables can be changed after deployment using the <code>config:set</code> command.</p>"},{"location":"design/index.html#runtime-detection","title":"Runtime detection","text":"<p><code>piku</code> follows a very simple set of rules to determine what kind of runtime is required, outlined in the configuration section</p>"},{"location":"design/index.html#application-isolation","title":"Application isolation","text":"<p>Application isolation can be tackled at several levels, the most relevant of which being:</p> <ul> <li>OS/process isolation</li> <li>Runtime/library isolation</li> </ul> <p>For 1.0, all applications run under the same <code>uid</code>, under separate branches of the same filesystem, and without any resource limiting.</p> <p>Ways to improve upon that (short of full containerisation) typically entail the use of a <code>chroot</code> jail environment (which is available under most POSIX systems in one form or another) or Linux kernel namespaces - both of which are supported by uWSGI (which can also handle resource limiting to a degree).</p> <p>As to runtime isolation, <code>piku</code> only provides <code>virtualenv</code> support until 1.0. Python apps can run under Python 2 or 3 depending on the setting of <code>PYTHON_VERSION</code>, but will always use pre-installed interpreters (Go, Node and Java support will share these limitations in each major version).</p>"},{"location":"design/index.html#internals","title":"Internals","text":"<p><code>piku</code> uses two <code>git</code> repositories for each app: a bare repository for client push, and a clone for deployment (which is efficient in terms of storage since <code>git</code> tries to use hardlinks on local clones whenever possible).</p> <p>This separation makes it easier to cope with long/large deployments and restore apps to a pristine condition, since the app will only go live after the deployment clone is reset (via <code>git checkout -f</code>).</p>"},{"location":"design/index.html#components","title":"Components","text":"<p>This diagram outlines how its components interact:</p> <pre><code>graph TD\n    subgraph \"systemd\"\n        nginx([nginx])\n        sshd([sshd])\n        uwsgi([uwsgi])\n    end\n    uwsgi--&gt;vassal([vassal])\n    vassal-.-&gt;uwsgi.ini\n    sshd--&gt;piku([piku.py])--&gt;repo[git repo]\n    Procfile--&gt;uwsgi.ini\n    an--&gt;app\n    repo---app\n    repo---ENV\n    repo---requirements.txt\n    repo---Procfile\n    requirements.txt--&gt;virtualenv\n    uwsgi.ini--&gt;virtualenv\n    ENV--&gt;an\n    ENV--&gt;uwsgi.ini\n    nginx-.-mn[master&lt;br&gt;nginx.conf]\n    mn-.-an[app&lt;br&gt;nginx.conf]</code></pre>"},{"location":"design/plugins.html","title":"Plugins","text":"<p>Thanks to jsenin, <code>piku</code> currently has experimental support for external plugins via #129. </p> <p>Plugins are inserted into the commands listing and can perform arbitrary actions. At this moment there are no official plugins, but here is an example file that should be placed at <code>~/.piku/plugins/postgres/__init__.py</code> that could contain the commands to manage a Postgres database:</p> <pre><code>import click\n\n@click.group()\ndef postgres():\n    \"\"\"Postgres command plugin\"\"\"\n    pass\n\n@postgres.command(\"postgres:create\")\n@click.argument('name')\n@click.argument('user')\n@click.argument('password')\ndef postgres_create():\n    \"\"\"Postgres create a database\"\"\"\n    pass\n\n@postgres.command(\"postgres:drop\")\n@click.argument('name')\ndef postgres_drop():\n    \"\"\"Postgres drops a database\"\"\"\n    pass\n\n@postgres.command(\"postgres:import\")\n@click.argument('name')\ndef postgres_drop():\n    \"\"\"Postgres import a database\"\"\"\n    pass\n\n@postgres.command(\"postgres:dump\")\n@click.argument('name')\ndef postgres_drop():\n    \"\"\"Postgres dumps a database SQL\"\"\"\n    pass\n\ndef cli_commands():\n    return postgres\n</code></pre>"},{"location":"install/index.html","title":"Installation","text":""},{"location":"install/index.html#tldr","title":"TL;DR:","text":"<p>If you are in a hurry to install it on your server and are OK with downloading random scripts off the Internet, <code>ssh</code> in as <code>root</code> and run this:</p> <pre><code>curl https://piku.github.io/get | sh\n</code></pre> <p>Warning</p> <p>This installation method is not recommended for production servers, and was added after an incredible amount of requests for a one-liner. It is safe to use on a fresh server, but you MUST always read scripts before running them.</p>"},{"location":"install/index.html#recommended-guaranteed-safe-installation-methods","title":"Recommended, Guaranteed Safe Installation Methods","text":"<p><code>piku</code> requires <code>Python 3</code>, uWSGI, <code>ssh</code>, and a Linux distribution that runs <code>systemd</code>, such as Raspbian Jessie/Debian 8+/Ubuntu/Fedora/CentOS.</p> <p>There are 3 main ways to install <code>piku</code> on a server:</p> <ol> <li> <p>Use piku-bootstrap to do it if your server is already provisioned (that is what the TL;DR command does)</p> </li> <li> <p>Use <code>cloud-init</code> to do it automatically at VPS build time (see the <code>cloud-init</code> repository, which has examples for most common cloud providers)</p> </li> <li> <p>Manually: Follow the guide below or one of the platform-specfic guides. </p> </li> </ol> <p>There is also an Ansible playbook.</p> <p>Contributing</p> <p>If you are running <code>piku</code> on specific Linux versions, feel free to contribute your own instructions.</p>"},{"location":"install/index.html#generic-installation-steps","title":"Generic Installation Steps","text":""},{"location":"install/index.html#set-up-the-piku-user","title":"Set up the <code>piku</code> user","text":"<p><code>piku</code> requires a separate user account to run. To create a new user with the right group membership (we're using the built-in <code>www-data</code> group because it's generally thought of as a less-privileged group), enter the following command:</p> <pre><code># pick a username\nexport PAAS_USERNAME=piku\n# create it\nsudo adduser --disabled-password --gecos 'PaaS access' --ingroup www-data $PAAS_USERNAME\n# copy &amp; setup piku.py\nsudo su - $PAAS_USERNAME -c \"wget https://raw.githubusercontent.com/piku/piku/master/piku.py &amp;&amp; python3 ~/piku.py setup\"\n</code></pre> <p>The <code>setup</code> output should be something like this:</p> <pre><code>Creating '/home/piku/.piku/apps'.\nCreating '/home/piku/.piku/repos'.\nCreating '/home/piku/.piku/envs'.\nCreating '/home/piku/.piku/uwsgi'.\nCreating '/home/piku/.piku/uwsgi-available'.\nCreating '/home/piku/.piku/uwsgi-enabled'.\nCreating '/home/piku/.piku/logs'.\nSetting '/home/piku/piku.py' as executable.\n</code></pre>"},{"location":"install/index.html#set-up-ssh-access","title":"Set up <code>ssh</code> access","text":"<p>If you don't have an <code>ssh</code> public key (or never used one before), you need to create one. The following instructions assume you're running some form of UNIX on your own machine (Windows users should check the documentation for their <code>ssh</code> client, unless you have Cygwin installed).</p> <p>On your own machine, issue the <code>ssh-keygen</code> command and follow the prompts:</p> <pre><code>ssh-keygen \n\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/youruser/.ssh/id_rsa): \nCreated directory '/home/youruser/.ssh'.\nEnter passphrase (empty for no passphrase): \nEnter same passphrase again: \nYour identification has been saved in /home/youruser/.ssh/id_rsa.\nYour public key has been saved in /home/youruser/.ssh/id_rsa.pub.\nThe key fingerprint is:\n85:29:07:cb:de:ad:be:ef:42:65:00:c8:d2:6b:9e:ff youruser@yourlaptop.lan\nThe key's randomart image is:\n+--[ RSA 2048]----+\n&lt;...&gt;\n+-----------------+\n</code></pre> <p>Copy the resulting <code>id_rsa.pub</code> (or equivalent, just make sure it's the public file) to your <code>piku</code> server and do the following:</p> <pre><code>sudo su - piku\npython3 piku.py setup:ssh /tmp/id_rsa.pub\n\nAdding key '85:29:07:cb:de:ad:be:ef:42:65:00:c8:d2:6b:9e:ff'.\n</code></pre> <p>Now if you look at <code>.ssh/authorized_keys</code>, you should see something like this:</p> <pre><code>sudo su - piku\ncat .ssh/authorized_keys\n\ncommand=\"FINGERPRINT=85:29:07:cb:de:ad:be:ef:42:65:00:c8:d2:6b:9e:ff NAME=default /home/piku/piku.py $SSH_ORIGINAL_COMMAND\",no-agent-forwarding,no-user-rc,no-X11-forwarding,no-port-forwarding ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDhTYZi/qeJBKgU3naI8FNjQgeMYnMsEtqrOmUc4lJoPNH2qBUTNkzwThGqsBm2HNLPURWMiEifBqF+kRixMud67Co7Zs9ys7pwFXkJB9bbZasd2JCGfVZ4UYXHnvgejSWkLAV/4bObhsbP2vWOmbbm91Cwn+PGJgoiW08yrd45lsDmgv9cUAJS3e8LkgVELvIDg49yM5ArB88oxwMEoUgWU2OniHmH0o1zw5I8WXHRhHOjb8cGsdTYfXEizRKKRTM2Mu6dKRt1GNL0UbWi8iS3uJHGD3AcQ4ApdMl5X0gTixKHponStOrSMy19/ltuIy8Sjr7KKPxz07ikMYr7Vpcp youruser@yourlaptop.lan\n</code></pre> <p>This line is what enables you to <code>ssh</code> (and perform <code>git</code> over <code>ssh</code> operations) to the <code>piku</code> user without a password, verifying your identity via your public key, restricting what can be done remotely and passing on to <code>piku</code> itself the commands you'll be issuing.</p>"},{"location":"install/index.html#test","title":"Test","text":"<p>From your machine, do:</p> <pre><code>ssh piku@pi.lan\n\nUsage: piku.py [OPTIONS] COMMAND [ARGS]...\n\n  The smallest PaaS you've ever seen\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  apps              List applications\n  config            Show application configuration\n  config:get        Retrieve a configuration setting\n  config:live       Show live configuration settings\n  config:set        Set a configuration setting\n  deploy            Deploy an application\n  destroy           Destroy an application\n  disable           Disable an application\n  enable            Enable an application\n  logs              Tail an application log\n  ps                Show application worker count\n  ps:scale          Show application configuration\n  restart           Restart an application\n  setup             Initialize paths\n  setup:ssh         Set up a new SSH key\nConnection to pi.lan closed.\n</code></pre>"},{"location":"install/INSTALL-centos-9.html","title":"Installation on CentOS 9","text":"<p>Note</p> <p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <p>All steps done as root (or add sudo if you prefer).</p>"},{"location":"install/INSTALL-centos-9.html#dependencies","title":"Dependencies","text":"<p>Before installing <code>piku</code>, you need to install the following packages:</p> <pre><code>dnf in -y ansible-core ansible-collection-ansible-posix ansible-collection-ansible-utils nginx nodejs npm openssl postgresql postgresql-server postgresql-contrib python3 python3-pip uwsgi uwsgi-logger-file uwsgi-logger-systemd\npip install click\n</code></pre>"},{"location":"install/INSTALL-centos-9.html#set-up-the-piku-user","title":"Set up the <code>piku</code> user","text":"<pre><code>adduser --groups nginx piku\n# copy &amp; setup piku.py\nsu - piku -c \"wget https://raw.githubusercontent.com/piku/piku/master/piku.py &amp;&amp; python3 ~/piku.py setup\"\n</code></pre>"},{"location":"install/INSTALL-centos-9.html#set-up-ssh-access","title":"Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"install/INSTALL-centos-9.html#uwsgi-configuration","title":"uWSGI Configuration","text":"<p>FYI The uWSGI Emperor \u2013 multi-app deployment</p> <pre><code>mv /home/piku/.piku/uwsgi/uwsgi.ini /etc/uwsgi.d/piku.ini # linking alone increases the host attack service if one can get inside the piku user or one of its apps, so moving is safer\nchown piku:piku /etc/uwsgi.d/piku.ini # In Tyrant mode (set by default in /etc/uwsgi.ini) the Emperor will run the vassal using the UID/GID of the vassal configuration file\nsystemctl restart uwsgi\njournalctl -feu uwsgi # see logs\n</code></pre>"},{"location":"install/INSTALL-centos-9.html#nginx-configuration","title":"<code>nginx</code> Configuration","text":"<p>FYI Setting up and configuring NGINX</p> <pre><code>echo \"include /home/piku/.piku/nginx/*.conf;\" &gt; /etc/nginx/conf.d/piku.conf\nsystemctl restart nginx\njournalctl -feu nginx # see logs\n</code></pre>"},{"location":"install/INSTALL-centos-9.html#set-up-systemdpath-to-reload-nginx-upon-config-changes","title":"Set up systemd.path to reload nginx upon config changes","text":"<pre><code># Set up systemd.path to reload nginx upon config changes\nsu -\ngit clone https://github.com/piku/piku.git # need a copy of some files\ncp -v piku/piku-nginx.{path,service} /etc/systemd/system/\nsystemctl enable piku-nginx.{path,service}\nsystemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `active: active (waiting)`\n</code></pre>"},{"location":"install/INSTALL-centos-9.html#notes","title":"Notes","text":""},{"location":"install/INSTALL-other.html","title":"Installation on other platforms","text":"<p>Note</p> <p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p>"},{"location":"install/INSTALL-other.html#dependencies","title":"Dependencies","text":"<p>Before running <code>piku</code> for the first time, you need to install the following Python packages at the system level:</p>"},{"location":"install/INSTALL-other.html#raspbian-jessie-debian-8-ubuntu-1604","title":"Raspbian Jessie, Debian 8, Ubuntu 16.04","text":"<pre><code>sudo apt-get install git python3-virtualenv python3-pip\nsudo pip3 install -U click\n</code></pre>"},{"location":"install/INSTALL-other.html#raspbian-wheezy","title":"Raspbian Wheezy","text":"<pre><code>sudo apt-get install git python3\nsudo easy_install3 -U pip3\nsudo pip3 install -U click virtualenv\n</code></pre> <p>These may or may not be installed already (<code>click</code> usually isn't). For Raspbian Wheezy this is the preferred approach, since current <code>apt</code> packages are fairly outdated.</p>"},{"location":"install/INSTALL-other.html#set-up-the-piku-user-set-up-ssh-access","title":"Set up the <code>piku</code> user, Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"install/INSTALL-other.html#uwsgi-installation-debian-linux-variants-any-architecture","title":"uWSGI Installation (Debian Linux variants, any architecture)","text":"<p>uWSGI can be installed in a variety of fashions. These instructions cover both pre-packaged and source installs depending on your system.</p>"},{"location":"install/INSTALL-other.html#raspbian-jessie-debian-8","title":"Raspbian Jessie, Debian 8","text":"<p>Warning</p> <p>These OS releases are no longer supported and these instructions are kept for reference purposes only.</p> <p>In Raspbian Jessie, Debian 8 and other <code>systemd</code> distributions where uWSGI is already available pre-compiled (but split into a number of plugins), do the following:</p> <p><pre><code># At the time of this writing, this installs uwsgi 2.0.7 on Raspbian Jessie.\n# You can also install uwsgi-plugins-all if you want to get runtime support for other languages\nsudo apt-get install uwsgi uwsgi-plugin-python3\n# refer to our executable using a link, in case there are more versions installed\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\n# disable the standard uwsgi startup script\nsudo systemctl disable uwsgi\n\n# add our own startup script\nsudo cp /tmp/uwsgi-piku.service /etc/systemd/system/\nsudo systemctl enable uwsgi-piku\nsudo systemctl start uwsgi-piku\n\n# check it's running\nsudo systemctl status uwsgi-piku.service\n</code></pre> Important Note: Make sure you run <code>piku.py setup</code> as outlined above before starting the service.</p> <p>Also, please note that <code>uwsgi-piku.service</code>, as provided, creates a <code>/run/uwsgi-piku</code> directory for it to place socket files and sundry. This is not actually used at the moment, since the <code>uwsgi</code> socket file is placed inside the <code>piku</code> user directory for consistency across OS distributions. This will be cleaned up in a later release.</p>"},{"location":"install/INSTALL-other.html#raspbian-wheezy_1","title":"Raspbian Wheezy","text":"<p>Warning</p> <p>This OS release is no longer supported and these instructions are kept for reference purposes only.</p> <p>Since Raspbian Wheezy is a fairly old distribution by now, its <code>uwsgi-*</code> packages are completely outdated (and depend on Python 2.6), so we have to compile and install our own version, as well as using an old-style <code>init</code> script to have it start automatically upon boot.</p> <p><pre><code>sudo apt-get install build-essential python-dev libpcre3-dev\n# At the time of this writing, this installs 2.0.12\nsudo pip install uwsgi\n# refer to our executable using a link, in case there are more versions installed\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\n\n# set up our init script\nsudo cp /tmp/uwsgi-piku.dist /etc/init.d/uwsgi-piku\nsudo chmod +x /etc/init.d/uwsgi-piku\nsudo update-rc.d uwsgi-piku defaults\nsudo service uwsgi-piku start\n</code></pre> Important Note: Make sure you run <code>python3 piku.py setup</code> as outlined above before starting the service.</p>"},{"location":"install/INSTALL-other.html#ubuntu-1404-lts","title":"Ubuntu 14.04 LTS","text":"<p>Warning</p> <p>This OS release is no longer supported and these instructions are kept for reference purposes only.</p> <p>This is a mix of both the above, and should change soon when we get 16.04. If you have trouble, install uWSGI via <code>pip</code> instead.</p> <pre><code># At the time of this writing, this installs uwsgi 1.9.17 on Ubuntu 14.04 LTS.\n# You can also install uwsgi-plugins-all if you want to get runtime support for other languages\nsudo apt-get install uwsgi uwsgi-plugin-python3\n# refer to our executable using a link, in case there are more versions installed\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\n\n# set up our init script\nsudo cp /tmp/uwsgi-piku.dist /etc/init.d/uwsgi-piku\nsudo chmod +x /etc/init.d/uwsgi-piku\nsudo update-rc.d uwsgi-piku defaults\nsudo service uwsgi-piku start\n</code></pre>"},{"location":"install/INSTALL-other.html#nginx-installation-raspbian-8-ubuntu-1604","title":"nginx Installation (Raspbian 8, Ubuntu 16.04)","text":"<p>Warning</p> <p>These OS releases are no longer supported and these instructions are kept for reference purposes only.</p> <p>Warning</p> <p>There is a bug in <code>nginx</code> 1.6.2 under Raspbian 8 that causes it to try to allocate around a gigabyte of RAM when using SSL with <code>SPDY</code>. I seriously recommend using Ubuntu instead, if you can, or disabling SSL altogether.</p> <pre><code>sudo apt-get install nginx\n# Set up nginx to pick up our config files\nsudo cp /tmp/nginx.default.dist /etc/nginx/sites-available/default\n# Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre>"},{"location":"install/INSTALL-other.html#java-8-installation-all-debian-linux-variants-on-raspberry-pi","title":"Java 8 Installation (All Debian Linux variants, on Raspberry Pi)","text":"<p>Warning</p> <p>OpenJDK 8 is no longer shipping with most distributions and these instructions are kept for reference purposes only.</p> <p>To be able to deploy Java apps, we're going to need to install Java (and, since we're going to be doing so on ARM, it's best to use Oracle's runtime). To do that, we're going to use the <code>webupd8team</code> PPA, which has a (cross-platform) Java installer.</p> <p>First, get rid of OpenJDK and import the PPA key:</p> <pre><code>sudo apt-get remove openjdk*\nsudo apt-key adv --recv-key --keyserver keyserver.ubuntu.com EEA14886\n</code></pre>"},{"location":"install/INSTALL-other.html#raspbian-jessie","title":"Raspbian Jessie","text":"<p>Warning</p> <p>This OS release is no longer supported and these instructions are kept for reference purposes only.</p> <p>For Jessie, we're going to use the <code>trusty</code> version of the installer:</p> <pre><code>sudo tee /etc/apt/sources.list.d/webupd8team.list\ndeb http://ppa.launchpad.net/webupd8team/java/ubuntu trusty main \ndeb-src http://ppa.launchpad.net/webupd8team/java/ubuntu trusty main\n^D\n</code></pre>"},{"location":"install/INSTALL-other.html#ubuntu-1604-for-arm","title":"Ubuntu 16.04 for ARM","text":"<p>Warning</p> <p>This OS release is no longer supported and these instructions are kept for reference purposes only.</p> <p>For Xenial, we're going to use its own version:</p> <pre><code>sudo tee /etc/apt/sources.list.d/webupd8team.list\ndeb http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main \ndeb-src http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main\n^D\n</code></pre> <p>Now perform the actual install:</p> <pre><code>sudo apt-get update\nsudo apt-get install oracle-java8-installer oracle-java8-set-default\n</code></pre>"},{"location":"install/INSTALL-other.html#go-installation-all-debian-linux-variants-on-raspberry-pi","title":"Go Installation (All Debian Linux variants, on Raspberry Pi)","text":"<p>This is EXPERIMENTAL and may not work at all.</p>"},{"location":"install/INSTALL-other.html#raspbian-wheezyjessie","title":"Raspbian Wheezy/Jessie","text":"<p>Warning</p> <p>Wheezy and Jessie are no longer supported and these instructions are kept for reference purposes only.</p> <p>Since Raspbian's Go compiler is version 1.0.2, we need something more up-to-date.</p> <ol> <li>Get an ARM 6 binary tarball</li> <li>Unpack it under the <code>piku</code> user like such:</li> </ol> <pre><code>sudo su - piku\ntar -zxvf /tmp/go1.5.3.linux-arm.tar.gz\n# remove unnecessary files\nrm -rf go/api go/blog go/doc go/misc go/test\n</code></pre> <ol> <li>Give it a temporary <code>GOPATH</code> and install <code>godep</code>:</li> </ol> <pre><code>sudo su - piku\nGOROOT=$HOME/go GOPATH=$HOME/gopath PATH=$PATH:$HOME/go/bin go get github.com/tools/godep\n# temporary workaround until this is fixed in godep or Go 1.7(?)\nGOROOT=$HOME/go GOPATH=$HOME/gopath PATH=$PATH:$HOME/go/bin go get golang.org/x/sys/unix\n</code></pre> <p>TODO: complete this.</p>"},{"location":"install/INSTALL-raspbian-9.4-stretch-10-buster.html","title":"Installation on Raspbian Stretch or Buster","text":"<p>Note</p> <p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <p><code>piku</code> setup is simplified in modern Debian versions, since it can take advantage of some packaging improvements in uWSGI and does not require a custom <code>systemd</code> service. However, Stretch still ships with Python 3.5, which means it's not an ideal environment for new deployments on both Intel and ARM devices (Buster, in turn, ships with Python 3.7).</p>"},{"location":"install/INSTALL-raspbian-9.4-stretch-10-buster.html#setting-up-your-raspberry-pi","title":"Setting up your Raspberry Pi","text":"<p>Download and install Raspbian onto an SD card.</p> <p>After you install it is recommended that you do the following to update your installation to the latest available software.</p> <pre><code># update apt-get\nsudo apt-get update\n\n# upgrade all software\nsudo apt-get upgrade\n</code></pre> <p>Configure your installation.  It is recommended that <code>Change Password</code> from the default and setup <code>Locale Options</code> (Locale and Timezone) and <code>EXPAND FILESYSTEM</code>.  You will also want to <code>Enable SSH</code>. <pre><code># configure your installation\nsudo raspi-config\n</code></pre></p> <p>At this point it is a good idea to <code>sudo shutdown -h now</code> and make a backup image of the card.</p>"},{"location":"install/INSTALL-raspbian-9.4-stretch-10-buster.html#dependencies","title":"Dependencies","text":"<p>Before installing <code>piku</code>, you need to install the following packages:</p> <pre><code>sudo apt-get install -y build-essential certbot git \\\n    libjpeg-dev libxml2-dev libxslt1-dev zlib1g-dev nginx \\\n    python-certbot-nginx python-dev python-pip python-virtualenv \\\n    python3-dev python3-pip python3-click python3-virtualenv \\\n    uwsgi uwsgi-plugin-asyncio-python3 uwsgi-plugin-gevent-python \\\n    uwsgi-plugin-python uwsgi-plugin-python3 uwsgi-plugin-tornado-python \\\n    uwsgi-plugin-lua5.1 uwsgi-plugin-lua5.2 uwsgi-plugin-luajit\n</code></pre>"},{"location":"install/INSTALL-raspbian-9.4-stretch-10-buster.html#set-up-the-piku-user-set-up-ssh-access","title":"Set up the <code>piku</code> user, Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"install/INSTALL-raspbian-9.4-stretch-10-buster.html#uwsgi-configuration","title":"uWSGI Configuration","text":"<p>uWSGI in Stretch and Buster requires very little configuration, since it is already properly packaged. All you need to do is create a symlink to the <code>piku</code> configuration file in <code>/etc/uwsgi/apps-enabled</code>:</p> <pre><code>sudo ln /home/$PAAS_USERNAME/.piku/uwsgi/uwsgi.ini /etc/uwsgi/apps-enabled/piku.ini\nsudo systemctl restart uwsgi\n</code></pre>"},{"location":"install/INSTALL-raspbian-9.4-stretch-10-buster.html#nginx-configuration","title":"<code>nginx</code> Configuration","text":"<p><code>piku</code> requires you to edit <code>/etc/nginx/sites-available/default</code> to the following, so it can inject new site configurations into <code>nginx</code>:</p> <pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root /var/www/html;\n    index index.html index.htm;\n    server_name _;\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n# replace `PAAS_USERNAME` with the username you created.\ninclude /home/PAAS_USERNAME/.piku/nginx/*.conf;\n</code></pre>"},{"location":"install/INSTALL-raspbian-9.4-stretch-10-buster.html#set-up-systemdpath-to-reload-nginx-upon-config-changes","title":"Set up systemd.path to reload nginx upon config changes","text":"<pre><code># Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre>"},{"location":"install/INSTALL-raspbian-9.4-stretch-10-buster.html#notes","title":"Notes","text":"<p>This file was last updated on June 2019</p>"},{"location":"install/INSTALL-ubuntu-16.04.html","title":"Ubuntu 16.04","text":"<p>Note</p> <p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <pre><code>sudo apt-get update\nsudo apt-get -y dist-upgrade\nsudo apt-get -y autoremove\nsudo apt-get install -y tmux vim htop fail2ban uwsgi uwsgi-plugin-python uwsgi-plugin-python3 uwsgi-plugin-asyncio-python3 uwsgi-plugin-gevent-python uwsgi-plugin-tornado-python nginx libxml2-dev libxslt1-dev python-dev zlib1g-dev build-essential git python3-virtualenv python3-pip python3-click\nsudo pip3 install -U click pip\nsudo adduser --disabled-password --gecos 'PaaS access' --ingroup www-data piku\n\n# move to /tmp and grab our distribution files\ncd /tmp\nwget https://raw.githubusercontent.com/piku/piku/master/piku.py\nwget https://raw.githubusercontent.com/piku/piku/master/piku-nginx.path\nwget https://raw.githubusercontent.com/piku/piku/master/piku-nginx.service\nwget https://raw.githubusercontent.com/piku/piku/master/nginx.default.dist\nwget https://raw.githubusercontent.com/piku/piku/master/uwsgi-piku.service\n# Set up nginx to pick up our config files\nsudo cp /tmp/nginx.default.dist /etc/nginx/sites-available/default\n# Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Restart NGINX\nsudo systemctl restart nginx\nsudo cp /tmp/uwsgi-piku.service /etc/systemd/system/\n# refer to our executable using a link, in case there are more versions installed\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\n# disable the standard uwsgi startup script\nsudo systemctl disable uwsgi\nsudo systemctl enable uwsgi-piku\nsudo su - piku\nmkdir ~/.ssh\nchmod 700 ~/.ssh\n# now copy the piku script to this user account\ncp /tmp/piku.py ~/piku.py\npython3 piku.py setup\n# Now import your SSH key using setup:ssh\n\nsudo systemctl start uwsgi-piku\n</code></pre>"},{"location":"install/INSTALL-ubuntu-18.04-bionic.html","title":"Installation on Ubuntu 18.04 LTS (Bionic)","text":"<p>Note</p> <p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <p><code>piku</code> setup is simplified in Bionic, since it can take advantage of some packaging improvements in uWSGI and does not require a custom <code>systemd</code> service. Since Bionic also ships with Python 3.6, this is an ideal environment for new deployments on both Intel and ARM devices.</p>"},{"location":"install/INSTALL-ubuntu-18.04-bionic.html#dependencies","title":"Dependencies","text":"<p>Before installing <code>piku</code>, you need to install the following packages:</p> <pre><code>sudo apt-get update\nsudo apt-get install -y build-essential certbot git \\\n    libjpeg-dev libxml2-dev libxslt1-dev zlib1g-dev nginx \\\n    python-certbot-nginx python-dev python-pip python-virtualenv \\\n    python3-dev python3-pip python3-click python3-virtualenv \\\n    uwsgi uwsgi-plugin-asyncio-python3 uwsgi-plugin-gevent-python \\\n    uwsgi-plugin-python uwsgi-plugin-python3 uwsgi-plugin-tornado-python\n</code></pre>"},{"location":"install/INSTALL-ubuntu-18.04-bionic.html#set-up-the-piku-user-set-up-ssh-access","title":"Set up the <code>piku</code> user, Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"install/INSTALL-ubuntu-18.04-bionic.html#uwsgi-configuration","title":"uWSGI Configuration","text":"<p>uWSGI requires very little configuration, since it is already properly packaged. All you need to do is place a link to the <code>piku</code> configuration file in <code>/etc/uwsgi/apps-enabled</code>:</p> <pre><code>sudo ln /home/$PAAS_USERNAME/.piku/uwsgi/uwsgi.ini /etc/uwsgi/apps-enabled/piku.ini\nsudo systemctl restart uwsgi\n</code></pre>"},{"location":"install/INSTALL-ubuntu-18.04-bionic.html#nginx-configuration","title":"<code>nginx</code> Configuration","text":"<p><code>piku</code> requires you to edit <code>/etc/nginx/sites-available/default</code> to the following, so it can inject new site configurations into <code>nginx</code>:</p> <pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root /var/www/html;\n    index index.html index.htm;\n    server_name _;\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n# replace `PAAS_USERNAME` with the username you created.\ninclude /home/PAAS_USERNAME/.piku/nginx/*.conf;\n</code></pre>"},{"location":"install/INSTALL-ubuntu-18.04-bionic.html#set-up-systemdpath-to-reload-nginx-upon-config-changes","title":"Set up systemd.path to reload nginx upon config changes","text":"<pre><code># Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre>"},{"location":"install/INSTALL-ubuntu-18.04-bionic.html#notes","title":"Notes","text":"<p>This file was last updated on November 2018</p>"},{"location":"install/INSTALL-ubuntu-22.04-jammy.html","title":"Installation on Ubuntu 22.04 LTS (Jammy)","text":"<p>Note</p> <p>This is a standalone, distribution-specific version of <code>INSTALL.md</code>. You do not need to read or follow the original file, but can refer to it for generic steps like setting up SSH keys (which are assumed to be common knowledge here)</p> <p><code>piku</code> setup is simplified in Jammy, since it can take advantage of some packaging improvements in uWSGI and does not require a custom <code>systemd</code> service. Since Jammy also ships with Python 3.10, this is an ideal environment for new deployments on both Intel and ARM devices.</p>"},{"location":"install/INSTALL-ubuntu-22.04-jammy.html#dependencies","title":"Dependencies","text":"<p>Before installing <code>piku</code>, you need to install the following packages:</p> <pre><code>sudo apt-get update\nsudo apt-get install -y build-essential certbot git \\\n    libjpeg-dev libxml2-dev libxslt1-dev zlib1g-dev nginx \\\n    python3-certbot-nginx \\\n    python3-dev python3-pip python3-click python3-virtualenv \\\n    uwsgi uwsgi-plugin-asyncio-python3 uwsgi-plugin-gevent-python3 \\\n    uwsgi-plugin-python3 uwsgi-plugin-tornado-python3\n</code></pre>"},{"location":"install/INSTALL-ubuntu-22.04-jammy.html#set-up-the-piku-user-set-up-ssh-access","title":"Set up the <code>piku</code> user, Set up SSH access","text":"<p>See INSTALL.md</p>"},{"location":"install/INSTALL-ubuntu-22.04-jammy.html#uwsgi-configuration","title":"uWSGI Configuration","text":"<p>uWSGI requires very little configuration, since it is already properly packaged. All you need to do is place a link to the <code>piku</code> configuration file in <code>/etc/uwsgi/apps-enabled</code>:</p> <pre><code>sudo ln /home/$PAAS_USERNAME/.piku/uwsgi/uwsgi.ini /etc/uwsgi/apps-enabled/piku.ini\nsudo systemctl restart uwsgi\n</code></pre>"},{"location":"install/INSTALL-ubuntu-22.04-jammy.html#nginx-configuration","title":"<code>nginx</code> Configuration","text":"<p><code>piku</code> requires you to edit <code>/etc/nginx/sites-available/default</code> to the following, so it can inject new site configurations into <code>nginx</code>:</p> <pre><code>server {\n    listen 80 default_server;\n    listen [::]:80 default_server;\n    root /var/www/html;\n    index index.html index.htm;\n    server_name _;\n    location / {\n        try_files $uri $uri/ =404;\n    }\n}\n# replace `PAAS_USERNAME` with the username you created.\ninclude /home/PAAS_USERNAME/.piku/nginx/*.conf;\n</code></pre>"},{"location":"install/INSTALL-ubuntu-22.04-jammy.html#set-up-systemdpath-to-reload-nginx-upon-config-changes","title":"Set up systemd.path to reload nginx upon config changes","text":"<pre><code># Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre>"},{"location":"install/INSTALL-ubuntu-22.04-jammy.html#notes","title":"Notes","text":"<p>This file was last updated on November 2018</p>"},{"location":"install/RASPBERRY_PI_QUICKSTART.html","title":"Setting up a Raspberry Pi Piku Server from Scratch","text":"<p>Warning</p> <p>These instructions are correct as of April 1st 2016. Quite a bit has changed since then in Raspberry Pi land, so you may need to adjust them accordingly.</p> <p>Start by flashing a SD card with the latest Raspbian Jessie Lite image.</p>"},{"location":"install/RASPBERRY_PI_QUICKSTART.html#do-this-in-your-raspberry-pi-as-pi-user","title":"Do this in your Raspberry Pi as 'pi' user","text":"<p>Boot it, launch raspi-config to perform (at least) the following configuration:</p> <pre><code># as 'pi' user\nsudo raspi-config\n</code></pre> <ul> <li>1) expand filesystem </li> <li>2) change default user password</li> <li>3) set up memory split as you wish (for a headless server, 16MB for GPU)</li> </ul> <p>Optionally:</p> <ul> <li>4) set up over-clocking.</li> </ul>"},{"location":"install/RASPBERRY_PI_QUICKSTART.html#secure-your-install","title":"Secure your install","text":"<p>Delete the existing SSH keys and recreate them (why? read this).</p> <pre><code># as 'pi' user\nsudo rm -v /etc/ssh/ssh_host_*\nsudo dpkg-reconfigure openssh-server\nsudo reboot\n</code></pre> <p>This will recreate the server keys. Next, update your system:</p> <pre><code># as 'pi' user\nsudo apt update\nsudo apt upgrade\n</code></pre>"},{"location":"install/RASPBERRY_PI_QUICKSTART.html#install-required-packages","title":"Install required packages","text":"<p>As of April 2016, the shipping versions with Raspbian are recent enough to run <code>piku</code>:</p> <p><pre><code># as 'pi' user\nsudo apt install -y python-virtualenv python-pip git uwsgi uwsgi-plugin-python nginx\nsudo pip install -U click\nsudo reboot\n</code></pre>  Meanwhile, go get the goodies while Raspberry Pi is rebooting</p> <p>(We assume you know about ssh keys and have one \"at hand\", you'll need to copy it)</p> <p>Clone the piku repo somewhere and copy files to your Raspberry Pi</p> <pre><code># as yourself in your desktop/laptop computer\nscp piku.py uwsgi-piku.service nginx.default.dist pi@your_machine:/tmp\nscp your_public_ssh_key.pub pi@your_machine:/tmp\n</code></pre>"},{"location":"install/RASPBERRY_PI_QUICKSTART.html#back-to-the-pi","title":"Back to the Pi","text":"<p>Prepare uWSGI (part one): <pre><code># as 'pi' user\nsudo ln -s `which uwsgi` /usr/local/bin/uwsgi-piku\nsudo systemctl disable uwsgi\nsudo cp /tmp/uwsgi-piku.service /etc/systemd/system/\nsudo systemctl daemon-reload\nsudo systemctl enable uwsgi-piku\n</code></pre></p> <p>Prepare nginx:</p> <pre><code>sudo apt-get install nginx\n# Set up nginx to pick up our config files\nsudo cp /tmp/nginx.default.dist /etc/nginx/sites-available/default\n# Set up systemd.path to reload nginx upon config changes\nsudo cp ./piku-nginx.{path, service} /etc/systemd/system/\nsudo systemctl enable piku-nginx.{path,service}\nsudo systemctl start piku-nginx.path\n# Check the status of piku-nginx.service\nsystemctl status piku-nginx.path # should return `Active: active (waiting)`\n# Restart NGINX\nsudo systemctl restart nginx\n</code></pre> <p>Create 'piku' user and set it up</p> <pre><code># as 'pi' user\nsudo adduser --disabled-password --gecos 'PaaS access' --ingroup www-data piku\nsudo su - piku\n# this is now done as 'piku' user\nmkdir ~/.ssh\nchmod 700 ~/.ssh\ncp /tmp/piku.py ~/piku.py\npython piku.py setup\npython piku.py setup:ssh /tmp/id_rsa.pub\n# return to 'pi' user\nexit\n</code></pre> <p>Prepare uWSGI (part two):</p> <p><pre><code># as 'pi' user\nsudo systemctl start uwsgi-piku\nsudo systemctl status uwsgi-piku.service\n</code></pre> If you're still here, odds are your Pi is ready for work</p>"},{"location":"install/RASPBERRY_PI_QUICKSTART.html#testing","title":"Testing","text":"<p>Go back to your machine and try these commands:</p> <pre><code># as yourself in your desktop/laptop computer\nssh piku@your_machine\n\nUsage: piku.py [OPTIONS] COMMAND [ARGS]...\n\n  The smallest PaaS you've ever seen\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  apps              List applications\n  config            Show application configuration\n  config:get        Retrieve a configuration setting\n  config:live       Show live configuration settings\n  config:set        Set a configuration setting\n  deploy            Deploy an application\n  destroy           Destroy an application\n  disable           Disable an application\n  enable            Enable an application\n  logs              Tail an application log\n  ps                Show application worker count\n  ps:scale          Show application configuration\n  restart           Restart an application\n  setup             Initialize paths\n  setup:ssh         Set up a new SSH key\nConnection to your_machine closed.\n</code></pre> <p>If you find any bugs with this quickstart guide, please let Luis Correia know ;)</p>"}]}